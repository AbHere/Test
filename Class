CREATE OR REPLACE FUNCTION IsFixingClausesConsistent(sicovamValue IN NUMBER)
RETURN VARCHAR2 IS
  g_has_date_ko        BOOLEAN := FALSE;
  g_has_sj_list_ko     BOOLEAN := FALSE;
  g_has_underlying_ko  BOOLEAN := FALSE;

  CURSOR c_baskets IS
    SELECT p.sicopanier
    FROM panier p
    WHERE p.sicovam = sicovamValue
      AND p.quantite = 1;

  FUNCTION build_result RETURN VARCHAR2 IS
    v_res VARCHAR2(200) := '';
  BEGIN
    IF g_has_date_ko       THEN v_res := v_res || 'date.ko,';       END IF;
    IF g_has_sj_list_ko    THEN v_res := v_res || 'sous_jacent.ko,'; END IF;
    IF g_has_underlying_ko THEN v_res := v_res || 'underlying.ko,';  END IF;

    IF v_res IS NULL OR v_res = '' THEN
      RETURN 'OK';
    ELSE
      RETURN RTRIM(v_res, ',');
    END IF;
  END;

  PROCEDURE check_code(p_code IN NUMBER) IS
    v_date_ko        PLS_INTEGER := 0;
    v_sj_list_ko     PLS_INTEGER := 0;
    v_underlying_ko  PLS_INTEGER := 0;
  BEGIN
    /* 
      Mapping tables :
      - cdc_ifc_clause_hybpan = closes (dates fin)    => cdc_ifc_datefin
      - cdc_ifc_clotures     = fixings (par date/SJ)  => cdc_ifc_date, cdc_ifc_code_sj
      - panier               = définition des SJ attendus
    */
    WITH
    -- closes et fixings au niveau p_code
    close_dates AS (
      SELECT DISTINCT c.cdc_ifc_datefin AS d
      FROM cdc_ifc_clause_hybpan c
      WHERE c.code = p_code
        AND c.cdc_ifc_datefin IS NOT NULL
    ),
    fixing_dates AS (
      SELECT DISTINCT f.cdc_ifc_date AS d
      FROM cdc_ifc_clotures f
      WHERE f.code = p_code
    ),
    counts_cf AS (
      SELECT (SELECT COUNT(*) FROM close_dates)  AS n_close,
             (SELECT COUNT(*) FROM fixing_dates) AS n_fix
      FROM dual
    ),

    -- Ensemble attendu des SJ, avec fallback :
    expected_from_titres AS (
      SELECT DISTINCT TRIM(TO_CHAR(p.sicopanier)) AS sj
      FROM titres t
      JOIN panier p ON p.sicovam = t.codesj
      WHERE t.sicovam = p_code
    ),
    expected_from_panier AS (
      SELECT DISTINCT TRIM(TO_CHAR(p.sicopanier)) AS sj
      FROM panier p
      WHERE p.sicovam = p_code
    ),
    choose_expected AS (
      SELECT (SELECT COUNT(*) FROM expected_from_titres) AS n_t,
             (SELECT COUNT(*) FROM expected_from_panier) AS n_p
      FROM dual
    ),
    expected_sj AS (
      -- priorité à TITRES→PANIER si non vide
      SELECT sj FROM expected_from_titres
      WHERE (SELECT n_t FROM choose_expected) > 0
      UNION ALL
      -- sinon PANIER direct
      SELECT sj FROM expected_from_panier
      WHERE (SELECT n_t FROM choose_expected) = 0
    ),
    expected_count AS (
      SELECT COUNT(*) AS n FROM expected_sj
    ),

    fixing_sj AS (
      SELECT DISTINCT TRIM(TO_CHAR(f.cdc_ifc_code_sj)) AS sj
      FROM cdc_ifc_clotures f
      WHERE f.code = p_code
        AND f.cdc_ifc_code_sj IS NOT NULL
    ),

    /* === RÈGLE 0 : si zéro close ET zéro fixing ⇒ OK (aucun KO) === */
    no_data_ok AS (
      SELECT 1 AS is_ok
      FROM counts_cf
      WHERE n_close = 0 AND n_fix = 0
    ),

    /* === RÈGLE 1 : Dates KO (seulement s'il existe des closes) === */
    date_issue AS (
      SELECT 1 AS has_issue
      FROM dual
      WHERE EXISTS (SELECT 1 FROM counts_cf WHERE n_close > 0)  -- guard
        AND EXISTS (
          SELECT 1
          FROM close_dates cd
          WHERE NOT EXISTS (
            SELECT 1 FROM fixing_dates fd WHERE fd.d = cd.d
          )
        )
    ),

    /* === RÈGLE 2 : Liste SJ KO (seulement s'il existe des closes) ===
       - Manques globaux : un SJ attendu jamais vu dans AUCUN fixing
       - Extras : un SJ dans fixings non présent dans l'attendu
         (on ne teste les "extras" que si expected_count > 0) */
    sj_list_issue AS (
      SELECT 1 AS has_issue
      FROM dual
      WHERE EXISTS (SELECT 1 FROM counts_cf WHERE n_close > 0)  -- guard
        AND (
              EXISTS (  -- manques
                SELECT 1
                FROM expected_sj e
                WHERE NOT EXISTS (SELECT 1 FROM fixing_sj f WHERE f.sj = e.sj)
              )
              OR (
                EXISTS (SELECT 1 FROM expected_count WHERE n > 0)  -- garde extras
                AND EXISTS (
                  SELECT 1
                  FROM fixing_sj f
                  WHERE NOT EXISTS (SELECT 1 FROM expected_sj e WHERE e.sj = f.sj)
                )
              )
            )
    ),

    /* === RÈGLE 3 : Couverture par date (underlying.ko) si closes existent ===
       Pour chaque date de close : #SJ présents (distinct) >= #SJ attendus */
    per_date_issue AS (
      SELECT 1 AS has_issue
      FROM dual
      WHERE EXISTS (SELECT 1 FROM counts_cf WHERE n_close > 0)  -- guard
        AND EXISTS (
          SELECT 1
          FROM close_dates cd
          CROSS JOIN expected_count ec
          LEFT JOIN (
            SELECT f.cdc_ifc_date AS d,
                   COUNT(DISTINCT TRIM(TO_CHAR(f.cdc_ifc_code_sj))) AS n_present
            FROM cdc_ifc_clotures f
            WHERE f.code = p_code
            GROUP BY f.cdc_ifc_date
          ) x ON x.d = cd.d
          WHERE NVL(x.n_present,0) < ec.n
        )
    )

    SELECT
      CASE WHEN EXISTS (SELECT 1 FROM no_data_ok)   THEN 0
           WHEN EXISTS (SELECT 1 FROM date_issue)   THEN 1 ELSE 0 END,
      CASE WHEN EXISTS (SELECT 1 FROM no_data_ok)   THEN 0
           WHEN EXISTS (SELECT 1 FROM sj_list_issue) THEN 1 ELSE 0 END,
      CASE WHEN EXISTS (SELECT 1 FROM no_data_ok)   THEN 0
           WHEN EXISTS (SELECT 1 FROM per_date_issue) THEN 1 ELSE 0 END
    INTO v_date_ko, v_sj_list_ko, v_underlying_ko
    FROM dual;

    IF v_date_ko        = 1 THEN g_has_date_ko       := TRUE; END IF;
    IF v_sj_list_ko     = 1 THEN g_has_sj_list_ko    := TRUE; END IF;
    IF v_underlying_ko  = 1 THEN g_has_underlying_ko := TRUE; END IF;
  END check_code;

BEGIN
  -- Contrôle de l'instrument
  check_code(sicovamValue);

  -- Contrôle de chaque panier rattaché (quantite=1)
  FOR r IN c_baskets LOOP
    check_code(r.sicopanier);
  END LOOP;

  RETURN build_result;

EXCEPTION
  WHEN OTHERS THEN
    RETURN 'Error: ' || SQLERRM;
END IsFixingClausesConsistent;
/
