/* CTE: identify the row where start_validity dropped below 2099-12-31 */
WITH change_row AS (
  SELECT
      ats.code,
      ats.sequence,
      ats.numero,
      ats.start_validity,
      ats.end_validity,
      LAG(ats.start_validity) OVER (
        PARTITION BY ats.code
        ORDER BY ats.numero
      ) AS prev_start
  FROM AUDIT_TIERSSETTLEMENT ats
  /* keep predicates sargable; add your filters (code, the two sequences, etc.) */
  WHERE ats.code = :p_code
    AND ats.sequence IN (:AuditTierSequence, :PreviousAuditTierSequence)
),
picked_change AS (
  SELECT *
  FROM change_row
  WHERE prev_start = DATE '2099-12-31'
    AND start_validity < DATE '2099-12-31'
)
SELECT
    /* your existing columns … */
    base_cols.*,

    /* changer info */
    ru.name          AS changer_name,
    atc.modif_date   AS changed_at
FROM (
    /* your original FROM/JOINs that compute the diff
       and already produce the two sequences; alias as base_cols */
    SELECT /* … existing long select … */ 
    FROM   /* … existing joins … */
    WHERE  /* … existing predicates … */
) base_cols

/* join the detected change row on the sequence you consider "after" */
JOIN picked_change pc
  ON pc.sequence = base_cols.sequence_after   -- use the right side from your diff

/* for that sequence, pick the most recent change from AUDIT_TIERS_COMPO */
CROSS APPLY (
  SELECT a.id, a.modif_date
  FROM   AUDIT_TIERS_COMPO a
  WHERE  a.sequence = pc.sequence
  ORDER  BY a.modif_date DESC
  FETCH FIRST 1 ROW ONLY
) atc

JOIN RISKUSERS ru
  ON ru.ident = atc.id;



_______



/* CTE: identify the row where start_validity dropped below 2099-12-31 */
WITH change_row AS (
  SELECT
      ats.code,
      ats.sequence,
      ats.numero,
      ats.start_validity,
      ats.end_validity,
      LAG(ats.start_validity) OVER (
        PARTITION BY ats.code
        ORDER BY ats.numero
      ) AS prev_start
  FROM AUDIT_TIERSSETTLEMENT ats
  /* keep predicates sargable; add your filters (code, the two sequences, etc.) */
  WHERE ats.code = :p_code
    AND ats.sequence IN (:AuditTierSequence, :PreviousAuditTierSequence)
),
picked_change AS (
  SELECT *
  FROM change_row
  WHERE prev_start = DATE '2099-12-31'
    AND start_validity < DATE '2099-12-31'
)
SELECT
    /* your existing columns … */
    base_cols.*,

    /* changer info */
    ru.name          AS changer_name,
    atc.modif_date   AS changed_at
FROM (
    /* your original FROM/JOINs that compute the diff
       and already produce the two sequences; alias as base_cols */
    SELECT /* … existing long select … */ 
    FROM   /* … existing joins … */
    WHERE  /* … existing predicates … */
) base_cols

/* join the detected change row on the sequence you consider "after" */
JOIN picked_change pc
  ON pc.sequence = base_cols.sequence_after   -- use the right side from your diff

/* for that sequence, pick the most recent change from AUDIT_TIERS_COMPO */
CROSS APPLY (
  SELECT a.id, a.modif_date
  FROM   AUDIT_TIERS_COMPO a
  WHERE  a.sequence = pc.sequence
  ORDER  BY a.modif_date DESC
  FETCH FIRST 1 ROW ONLY
) atc

JOIN RISKUSERS ru
  ON ru.ident = atc.id;

____ minimal


WITH ordered AS (
  SELECT
    ats.*,
    LAG(ats.start_validity) OVER (PARTITION BY ats.code ORDER BY ats.numero) AS prev_start
  FROM AUDIT_TIERSSETTLEMENT ats
  WHERE ats.code = :p_code
),
the_change AS (
  SELECT code, sequence, numero, start_validity
  FROM   ordered
  WHERE  prev_start     = DATE '2099-12-31'
     AND start_validity < DATE '2099-12-31'
)
SELECT
  c.code,
  c.sequence,
  c.start_validity,
  ru.name        AS changer_name,
  a.modif_date   AS changed_at
FROM the_change c
CROSS APPLY (
  SELECT id, modif_date
  FROM   AUDIT_TIERS_COMPO
  WHERE  sequence = c.sequence
  ORDER  BY modif_date DESC
  FETCH FIRST 1 ROW ONLY
) a
JOIN RISKUSERS ru
  ON ru.ident = a.id;

